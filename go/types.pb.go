// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types.proto

package messages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import protobuf "github.com/skycoin/hardware-wallet-protob/go/google/protobuf"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// *
// Type of failures returned by Failure message
// @used_in Failure
type FailureType int32

const (
	FailureType_Failure_UnexpectedMessage FailureType = 1
	FailureType_Failure_ButtonExpected    FailureType = 2
	FailureType_Failure_DataError         FailureType = 3
	FailureType_Failure_ActionCancelled   FailureType = 4
	FailureType_Failure_PinExpected       FailureType = 5
	FailureType_Failure_PinCancelled      FailureType = 6
	FailureType_Failure_PinInvalid        FailureType = 7
	FailureType_Failure_InvalidSignature  FailureType = 8
	FailureType_Failure_ProcessError      FailureType = 9
	FailureType_Failure_NotEnoughFunds    FailureType = 10
	FailureType_Failure_NotInitialized    FailureType = 11
	FailureType_Failure_PinMismatch       FailureType = 12
	FailureType_Failure_AddressGeneration FailureType = 13
	FailureType_Failure_FirmwarePanic     FailureType = 14
	FailureType_Failure_FirmwareError     FailureType = 99
)

var FailureType_name = map[int32]string{
	1:  "Failure_UnexpectedMessage",
	2:  "Failure_ButtonExpected",
	3:  "Failure_DataError",
	4:  "Failure_ActionCancelled",
	5:  "Failure_PinExpected",
	6:  "Failure_PinCancelled",
	7:  "Failure_PinInvalid",
	8:  "Failure_InvalidSignature",
	9:  "Failure_ProcessError",
	10: "Failure_NotEnoughFunds",
	11: "Failure_NotInitialized",
	12: "Failure_PinMismatch",
	13: "Failure_AddressGeneration",
	14: "Failure_FirmwarePanic",
	99: "Failure_FirmwareError",
}
var FailureType_value = map[string]int32{
	"Failure_UnexpectedMessage": 1,
	"Failure_ButtonExpected":    2,
	"Failure_DataError":         3,
	"Failure_ActionCancelled":   4,
	"Failure_PinExpected":       5,
	"Failure_PinCancelled":      6,
	"Failure_PinInvalid":        7,
	"Failure_InvalidSignature":  8,
	"Failure_ProcessError":      9,
	"Failure_NotEnoughFunds":    10,
	"Failure_NotInitialized":    11,
	"Failure_PinMismatch":       12,
	"Failure_AddressGeneration": 13,
	"Failure_FirmwarePanic":     14,
	"Failure_FirmwareError":     99,
}

func (x FailureType) Enum() *FailureType {
	p := new(FailureType)
	*p = x
	return p
}
func (x FailureType) String() string {
	return proto.EnumName(FailureType_name, int32(x))
}
func (x *FailureType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FailureType_value, data, "FailureType")
	if err != nil {
		return err
	}
	*x = FailureType(value)
	return nil
}
func (FailureType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{0}
}

// *
// Type of script which will be used for transaction output
// @used_in TxOutputType
type OutputScriptType int32

const (
	OutputScriptType_PAYTOADDRESS     OutputScriptType = 0
	OutputScriptType_PAYTOSCRIPTHASH  OutputScriptType = 1
	OutputScriptType_PAYTOMULTISIG    OutputScriptType = 2
	OutputScriptType_PAYTOOPRETURN    OutputScriptType = 3
	OutputScriptType_PAYTOWITNESS     OutputScriptType = 4
	OutputScriptType_PAYTOP2SHWITNESS OutputScriptType = 5
)

var OutputScriptType_name = map[int32]string{
	0: "PAYTOADDRESS",
	1: "PAYTOSCRIPTHASH",
	2: "PAYTOMULTISIG",
	3: "PAYTOOPRETURN",
	4: "PAYTOWITNESS",
	5: "PAYTOP2SHWITNESS",
}
var OutputScriptType_value = map[string]int32{
	"PAYTOADDRESS":     0,
	"PAYTOSCRIPTHASH":  1,
	"PAYTOMULTISIG":    2,
	"PAYTOOPRETURN":    3,
	"PAYTOWITNESS":     4,
	"PAYTOP2SHWITNESS": 5,
}

func (x OutputScriptType) Enum() *OutputScriptType {
	p := new(OutputScriptType)
	*p = x
	return p
}
func (x OutputScriptType) String() string {
	return proto.EnumName(OutputScriptType_name, int32(x))
}
func (x *OutputScriptType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OutputScriptType_value, data, "OutputScriptType")
	if err != nil {
		return err
	}
	*x = OutputScriptType(value)
	return nil
}
func (OutputScriptType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{1}
}

// *
// Type of script which will be used for transaction output
// @used_in TxInputType
type InputScriptType int32

const (
	InputScriptType_SPENDADDRESS     InputScriptType = 0
	InputScriptType_SPENDMULTISIG    InputScriptType = 1
	InputScriptType_EXTERNAL         InputScriptType = 2
	InputScriptType_SPENDWITNESS     InputScriptType = 3
	InputScriptType_SPENDP2SHWITNESS InputScriptType = 4
)

var InputScriptType_name = map[int32]string{
	0: "SPENDADDRESS",
	1: "SPENDMULTISIG",
	2: "EXTERNAL",
	3: "SPENDWITNESS",
	4: "SPENDP2SHWITNESS",
}
var InputScriptType_value = map[string]int32{
	"SPENDADDRESS":     0,
	"SPENDMULTISIG":    1,
	"EXTERNAL":         2,
	"SPENDWITNESS":     3,
	"SPENDP2SHWITNESS": 4,
}

func (x InputScriptType) Enum() *InputScriptType {
	p := new(InputScriptType)
	*p = x
	return p
}
func (x InputScriptType) String() string {
	return proto.EnumName(InputScriptType_name, int32(x))
}
func (x *InputScriptType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(InputScriptType_value, data, "InputScriptType")
	if err != nil {
		return err
	}
	*x = InputScriptType(value)
	return nil
}
func (InputScriptType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{2}
}

// *
// Type of information required by transaction signing process
// @used_in TxRequest
type RequestType int32

const (
	RequestType_TXINPUT     RequestType = 0
	RequestType_TXOUTPUT    RequestType = 1
	RequestType_TXMETA      RequestType = 2
	RequestType_TXFINISHED  RequestType = 3
	RequestType_TXEXTRADATA RequestType = 4
)

var RequestType_name = map[int32]string{
	0: "TXINPUT",
	1: "TXOUTPUT",
	2: "TXMETA",
	3: "TXFINISHED",
	4: "TXEXTRADATA",
}
var RequestType_value = map[string]int32{
	"TXINPUT":     0,
	"TXOUTPUT":    1,
	"TXMETA":      2,
	"TXFINISHED":  3,
	"TXEXTRADATA": 4,
}

func (x RequestType) Enum() *RequestType {
	p := new(RequestType)
	*p = x
	return p
}
func (x RequestType) String() string {
	return proto.EnumName(RequestType_name, int32(x))
}
func (x *RequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(RequestType_value, data, "RequestType")
	if err != nil {
		return err
	}
	*x = RequestType(value)
	return nil
}
func (RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{3}
}

// *
// Type of button request
// @used_in ButtonRequest
type ButtonRequestType int32

const (
	ButtonRequestType_ButtonRequest_Other             ButtonRequestType = 1
	ButtonRequestType_ButtonRequest_FeeOverThreshold  ButtonRequestType = 2
	ButtonRequestType_ButtonRequest_ConfirmOutput     ButtonRequestType = 3
	ButtonRequestType_ButtonRequest_ResetDevice       ButtonRequestType = 4
	ButtonRequestType_ButtonRequest_ConfirmWord       ButtonRequestType = 5
	ButtonRequestType_ButtonRequest_WipeDevice        ButtonRequestType = 6
	ButtonRequestType_ButtonRequest_ProtectCall       ButtonRequestType = 7
	ButtonRequestType_ButtonRequest_SignTx            ButtonRequestType = 8
	ButtonRequestType_ButtonRequest_FirmwareCheck     ButtonRequestType = 9
	ButtonRequestType_ButtonRequest_Address           ButtonRequestType = 10
	ButtonRequestType_ButtonRequest_PublicKey         ButtonRequestType = 11
	ButtonRequestType_ButtonRequest_MnemonicWordCount ButtonRequestType = 12
	ButtonRequestType_ButtonRequest_MnemonicInput     ButtonRequestType = 13
	ButtonRequestType_ButtonRequest_PassphraseType    ButtonRequestType = 14
)

var ButtonRequestType_name = map[int32]string{
	1:  "ButtonRequest_Other",
	2:  "ButtonRequest_FeeOverThreshold",
	3:  "ButtonRequest_ConfirmOutput",
	4:  "ButtonRequest_ResetDevice",
	5:  "ButtonRequest_ConfirmWord",
	6:  "ButtonRequest_WipeDevice",
	7:  "ButtonRequest_ProtectCall",
	8:  "ButtonRequest_SignTx",
	9:  "ButtonRequest_FirmwareCheck",
	10: "ButtonRequest_Address",
	11: "ButtonRequest_PublicKey",
	12: "ButtonRequest_MnemonicWordCount",
	13: "ButtonRequest_MnemonicInput",
	14: "ButtonRequest_PassphraseType",
}
var ButtonRequestType_value = map[string]int32{
	"ButtonRequest_Other":             1,
	"ButtonRequest_FeeOverThreshold":  2,
	"ButtonRequest_ConfirmOutput":     3,
	"ButtonRequest_ResetDevice":       4,
	"ButtonRequest_ConfirmWord":       5,
	"ButtonRequest_WipeDevice":        6,
	"ButtonRequest_ProtectCall":       7,
	"ButtonRequest_SignTx":            8,
	"ButtonRequest_FirmwareCheck":     9,
	"ButtonRequest_Address":           10,
	"ButtonRequest_PublicKey":         11,
	"ButtonRequest_MnemonicWordCount": 12,
	"ButtonRequest_MnemonicInput":     13,
	"ButtonRequest_PassphraseType":    14,
}

func (x ButtonRequestType) Enum() *ButtonRequestType {
	p := new(ButtonRequestType)
	*p = x
	return p
}
func (x ButtonRequestType) String() string {
	return proto.EnumName(ButtonRequestType_name, int32(x))
}
func (x *ButtonRequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ButtonRequestType_value, data, "ButtonRequestType")
	if err != nil {
		return err
	}
	*x = ButtonRequestType(value)
	return nil
}
func (ButtonRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{4}
}

// *
// Type of PIN request
// @used_in PinMatrixRequest
type PinMatrixRequestType int32

const (
	PinMatrixRequestType_PinMatrixRequestType_Current   PinMatrixRequestType = 1
	PinMatrixRequestType_PinMatrixRequestType_NewFirst  PinMatrixRequestType = 2
	PinMatrixRequestType_PinMatrixRequestType_NewSecond PinMatrixRequestType = 3
)

var PinMatrixRequestType_name = map[int32]string{
	1: "PinMatrixRequestType_Current",
	2: "PinMatrixRequestType_NewFirst",
	3: "PinMatrixRequestType_NewSecond",
}
var PinMatrixRequestType_value = map[string]int32{
	"PinMatrixRequestType_Current":   1,
	"PinMatrixRequestType_NewFirst":  2,
	"PinMatrixRequestType_NewSecond": 3,
}

func (x PinMatrixRequestType) Enum() *PinMatrixRequestType {
	p := new(PinMatrixRequestType)
	*p = x
	return p
}
func (x PinMatrixRequestType) String() string {
	return proto.EnumName(PinMatrixRequestType_name, int32(x))
}
func (x *PinMatrixRequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PinMatrixRequestType_value, data, "PinMatrixRequestType")
	if err != nil {
		return err
	}
	*x = PinMatrixRequestType(value)
	return nil
}
func (PinMatrixRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{5}
}

// *
// Type of Recovery Word request
// @used_in WordRequest
type WordRequestType int32

const (
	WordRequestType_WordRequestType_Plain   WordRequestType = 0
	WordRequestType_WordRequestType_Matrix9 WordRequestType = 1
	WordRequestType_WordRequestType_Matrix6 WordRequestType = 2
)

var WordRequestType_name = map[int32]string{
	0: "WordRequestType_Plain",
	1: "WordRequestType_Matrix9",
	2: "WordRequestType_Matrix6",
}
var WordRequestType_value = map[string]int32{
	"WordRequestType_Plain":   0,
	"WordRequestType_Matrix9": 1,
	"WordRequestType_Matrix6": 2,
}

func (x WordRequestType) Enum() *WordRequestType {
	p := new(WordRequestType)
	*p = x
	return p
}
func (x WordRequestType) String() string {
	return proto.EnumName(WordRequestType_name, int32(x))
}
func (x *WordRequestType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(WordRequestType_value, data, "WordRequestType")
	if err != nil {
		return err
	}
	*x = WordRequestType(value)
	return nil
}
func (WordRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{6}
}

// *
// Flags used to build firmware
// @used_in Features
// @warning it's very important to preserve the order of the fields, and add
// @warning the new ones in a monotonic fashion as this can broke existing code.
type FirmwareFeatures int32

const (
	FirmwareFeatures_RequireGetEntropyConfirm          FirmwareFeatures = 1
	FirmwareFeatures_IsGetEntropyEnabled               FirmwareFeatures = 2
	FirmwareFeatures_IsEmulator                        FirmwareFeatures = 4
	FirmwareFeatures_FirmwareFeatures_RdpDebugDisabled FirmwareFeatures = 8
	FirmwareFeatures_FirmwareFeatures_RdpMemProtect    FirmwareFeatures = 16
)

var FirmwareFeatures_name = map[int32]string{
	1:  "RequireGetEntropyConfirm",
	2:  "IsGetEntropyEnabled",
	4:  "IsEmulator",
	8:  "FirmwareFeatures_RdpDebugDisabled",
	16: "FirmwareFeatures_RdpMemProtect",
}
var FirmwareFeatures_value = map[string]int32{
	"RequireGetEntropyConfirm":          1,
	"IsGetEntropyEnabled":               2,
	"IsEmulator":                        4,
	"FirmwareFeatures_RdpDebugDisabled": 8,
	"FirmwareFeatures_RdpMemProtect":    16,
}

func (x FirmwareFeatures) Enum() *FirmwareFeatures {
	p := new(FirmwareFeatures)
	*p = x
	return p
}
func (x FirmwareFeatures) String() string {
	return proto.EnumName(FirmwareFeatures_name, int32(x))
}
func (x *FirmwareFeatures) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FirmwareFeatures_value, data, "FirmwareFeatures")
	if err != nil {
		return err
	}
	*x = FirmwareFeatures(value)
	return nil
}
func (FirmwareFeatures) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{7}
}

// *
// Ask Skywallet to generate a skycoin address
// @used_in SkycoinAddress
type SkycoinAddressType int32

const (
	SkycoinAddressType_AddressTypeSkycoin SkycoinAddressType = 1
	SkycoinAddressType_AddressTypeBitcoin SkycoinAddressType = 2
)

var SkycoinAddressType_name = map[int32]string{
	1: "AddressTypeSkycoin",
	2: "AddressTypeBitcoin",
}
var SkycoinAddressType_value = map[string]int32{
	"AddressTypeSkycoin": 1,
	"AddressTypeBitcoin": 2,
}

func (x SkycoinAddressType) Enum() *SkycoinAddressType {
	p := new(SkycoinAddressType)
	*p = x
	return p
}
func (x SkycoinAddressType) String() string {
	return proto.EnumName(SkycoinAddressType_name, int32(x))
}
func (x *SkycoinAddressType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SkycoinAddressType_value, data, "SkycoinAddressType")
	if err != nil {
		return err
	}
	*x = SkycoinAddressType(value)
	return nil
}
func (SkycoinAddressType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{8}
}

// *
// Structure representing BIP32 (hierarchical deterministic) node
// Used for imports of private key into the device and exporting public key out of device
// @used_in PublicKey
// @used_in LoadDevice
// @used_in DebugLinkState
// @used_in Storage
type HDNodeType struct {
	Depth                *uint32  `protobuf:"varint,1,req,name=depth" json:"depth,omitempty"`
	Fingerprint          *uint32  `protobuf:"varint,2,req,name=fingerprint" json:"fingerprint,omitempty"`
	ChildNum             *uint32  `protobuf:"varint,3,req,name=child_num,json=childNum" json:"child_num,omitempty"`
	ChainCode            []byte   `protobuf:"bytes,4,req,name=chain_code,json=chainCode" json:"chain_code,omitempty"`
	PrivateKey           []byte   `protobuf:"bytes,5,opt,name=private_key,json=privateKey" json:"private_key,omitempty"`
	PublicKey            []byte   `protobuf:"bytes,6,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HDNodeType) Reset()         { *m = HDNodeType{} }
func (m *HDNodeType) String() string { return proto.CompactTextString(m) }
func (*HDNodeType) ProtoMessage()    {}
func (*HDNodeType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{0}
}
func (m *HDNodeType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDNodeType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDNodeType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HDNodeType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDNodeType.Merge(dst, src)
}
func (m *HDNodeType) XXX_Size() int {
	return m.Size()
}
func (m *HDNodeType) XXX_DiscardUnknown() {
	xxx_messageInfo_HDNodeType.DiscardUnknown(m)
}

var xxx_messageInfo_HDNodeType proto.InternalMessageInfo

func (m *HDNodeType) GetDepth() uint32 {
	if m != nil && m.Depth != nil {
		return *m.Depth
	}
	return 0
}

func (m *HDNodeType) GetFingerprint() uint32 {
	if m != nil && m.Fingerprint != nil {
		return *m.Fingerprint
	}
	return 0
}

func (m *HDNodeType) GetChildNum() uint32 {
	if m != nil && m.ChildNum != nil {
		return *m.ChildNum
	}
	return 0
}

func (m *HDNodeType) GetChainCode() []byte {
	if m != nil {
		return m.ChainCode
	}
	return nil
}

func (m *HDNodeType) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *HDNodeType) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

type HDNodePathType struct {
	Node                 *HDNodeType `protobuf:"bytes,1,req,name=node" json:"node,omitempty"`
	AddressN             []uint32    `protobuf:"varint,2,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *HDNodePathType) Reset()         { *m = HDNodePathType{} }
func (m *HDNodePathType) String() string { return proto.CompactTextString(m) }
func (*HDNodePathType) ProtoMessage()    {}
func (*HDNodePathType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{1}
}
func (m *HDNodePathType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HDNodePathType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HDNodePathType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HDNodePathType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HDNodePathType.Merge(dst, src)
}
func (m *HDNodePathType) XXX_Size() int {
	return m.Size()
}
func (m *HDNodePathType) XXX_DiscardUnknown() {
	xxx_messageInfo_HDNodePathType.DiscardUnknown(m)
}

var xxx_messageInfo_HDNodePathType proto.InternalMessageInfo

func (m *HDNodePathType) GetNode() *HDNodeType {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *HDNodePathType) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

// *
// Structure representing Coin
// @used_in Features
type CoinType struct {
	CoinName             *string  `protobuf:"bytes,1,opt,name=coin_name,json=coinName" json:"coin_name,omitempty"`
	CoinShortcut         *string  `protobuf:"bytes,2,opt,name=coin_shortcut,json=coinShortcut" json:"coin_shortcut,omitempty"`
	AddressType          *uint32  `protobuf:"varint,3,opt,name=address_type,json=addressType,def=0" json:"address_type,omitempty"`
	MaxfeeKb             *uint64  `protobuf:"varint,4,opt,name=maxfee_kb,json=maxfeeKb" json:"maxfee_kb,omitempty"`
	AddressTypeP2Sh      *uint32  `protobuf:"varint,5,opt,name=address_type_p2sh,json=addressTypeP2sh,def=5" json:"address_type_p2sh,omitempty"`
	SignedMessageHeader  *string  `protobuf:"bytes,8,opt,name=signed_message_header,json=signedMessageHeader" json:"signed_message_header,omitempty"`
	XpubMagic            *uint32  `protobuf:"varint,9,opt,name=xpub_magic,json=xpubMagic,def=76067358" json:"xpub_magic,omitempty"`
	XprvMagic            *uint32  `protobuf:"varint,10,opt,name=xprv_magic,json=xprvMagic,def=76066276" json:"xprv_magic,omitempty"`
	Segwit               *bool    `protobuf:"varint,11,opt,name=segwit" json:"segwit,omitempty"`
	Forkid               *uint32  `protobuf:"varint,12,opt,name=forkid" json:"forkid,omitempty"`
	ForceBip143          *bool    `protobuf:"varint,13,opt,name=force_bip143,json=forceBip143" json:"force_bip143,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CoinType) Reset()         { *m = CoinType{} }
func (m *CoinType) String() string { return proto.CompactTextString(m) }
func (*CoinType) ProtoMessage()    {}
func (*CoinType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{2}
}
func (m *CoinType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoinType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoinType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CoinType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoinType.Merge(dst, src)
}
func (m *CoinType) XXX_Size() int {
	return m.Size()
}
func (m *CoinType) XXX_DiscardUnknown() {
	xxx_messageInfo_CoinType.DiscardUnknown(m)
}

var xxx_messageInfo_CoinType proto.InternalMessageInfo

const Default_CoinType_AddressType uint32 = 0
const Default_CoinType_AddressTypeP2Sh uint32 = 5
const Default_CoinType_XpubMagic uint32 = 76067358
const Default_CoinType_XprvMagic uint32 = 76066276

func (m *CoinType) GetCoinName() string {
	if m != nil && m.CoinName != nil {
		return *m.CoinName
	}
	return ""
}

func (m *CoinType) GetCoinShortcut() string {
	if m != nil && m.CoinShortcut != nil {
		return *m.CoinShortcut
	}
	return ""
}

func (m *CoinType) GetAddressType() uint32 {
	if m != nil && m.AddressType != nil {
		return *m.AddressType
	}
	return Default_CoinType_AddressType
}

func (m *CoinType) GetMaxfeeKb() uint64 {
	if m != nil && m.MaxfeeKb != nil {
		return *m.MaxfeeKb
	}
	return 0
}

func (m *CoinType) GetAddressTypeP2Sh() uint32 {
	if m != nil && m.AddressTypeP2Sh != nil {
		return *m.AddressTypeP2Sh
	}
	return Default_CoinType_AddressTypeP2Sh
}

func (m *CoinType) GetSignedMessageHeader() string {
	if m != nil && m.SignedMessageHeader != nil {
		return *m.SignedMessageHeader
	}
	return ""
}

func (m *CoinType) GetXpubMagic() uint32 {
	if m != nil && m.XpubMagic != nil {
		return *m.XpubMagic
	}
	return Default_CoinType_XpubMagic
}

func (m *CoinType) GetXprvMagic() uint32 {
	if m != nil && m.XprvMagic != nil {
		return *m.XprvMagic
	}
	return Default_CoinType_XprvMagic
}

func (m *CoinType) GetSegwit() bool {
	if m != nil && m.Segwit != nil {
		return *m.Segwit
	}
	return false
}

func (m *CoinType) GetForkid() uint32 {
	if m != nil && m.Forkid != nil {
		return *m.Forkid
	}
	return 0
}

func (m *CoinType) GetForceBip143() bool {
	if m != nil && m.ForceBip143 != nil {
		return *m.ForceBip143
	}
	return false
}

// *
// Type of redeem script used in input
// @used_in TxInputType
type MultisigRedeemScriptType struct {
	Pubkeys              []*HDNodePathType `protobuf:"bytes,1,rep,name=pubkeys" json:"pubkeys,omitempty"`
	Signatures           [][]byte          `protobuf:"bytes,2,rep,name=signatures" json:"signatures,omitempty"`
	M                    *uint32           `protobuf:"varint,3,opt,name=m" json:"m,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *MultisigRedeemScriptType) Reset()         { *m = MultisigRedeemScriptType{} }
func (m *MultisigRedeemScriptType) String() string { return proto.CompactTextString(m) }
func (*MultisigRedeemScriptType) ProtoMessage()    {}
func (*MultisigRedeemScriptType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{3}
}
func (m *MultisigRedeemScriptType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultisigRedeemScriptType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultisigRedeemScriptType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MultisigRedeemScriptType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultisigRedeemScriptType.Merge(dst, src)
}
func (m *MultisigRedeemScriptType) XXX_Size() int {
	return m.Size()
}
func (m *MultisigRedeemScriptType) XXX_DiscardUnknown() {
	xxx_messageInfo_MultisigRedeemScriptType.DiscardUnknown(m)
}

var xxx_messageInfo_MultisigRedeemScriptType proto.InternalMessageInfo

func (m *MultisigRedeemScriptType) GetPubkeys() []*HDNodePathType {
	if m != nil {
		return m.Pubkeys
	}
	return nil
}

func (m *MultisigRedeemScriptType) GetSignatures() [][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *MultisigRedeemScriptType) GetM() uint32 {
	if m != nil && m.M != nil {
		return *m.M
	}
	return 0
}

// *
// Structure representing transaction input
// @used_in SimpleSignTx
// @used_in TransactionType
type TxInputType struct {
	AddressN             []uint32                  `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	PrevHash             []byte                    `protobuf:"bytes,2,req,name=prev_hash,json=prevHash" json:"prev_hash,omitempty"`
	PrevIndex            *uint32                   `protobuf:"varint,3,req,name=prev_index,json=prevIndex" json:"prev_index,omitempty"`
	ScriptSig            []byte                    `protobuf:"bytes,4,opt,name=script_sig,json=scriptSig" json:"script_sig,omitempty"`
	Sequence             *uint32                   `protobuf:"varint,5,opt,name=sequence,def=4294967295" json:"sequence,omitempty"`
	ScriptType           *InputScriptType          `protobuf:"varint,6,opt,name=script_type,json=scriptType,enum=InputScriptType,def=0" json:"script_type,omitempty"`
	Multisig             *MultisigRedeemScriptType `protobuf:"bytes,7,opt,name=multisig" json:"multisig,omitempty"`
	Amount               *uint64                   `protobuf:"varint,8,opt,name=amount" json:"amount,omitempty"`
	DecredTree           *uint32                   `protobuf:"varint,9,opt,name=decred_tree,json=decredTree" json:"decred_tree,omitempty"`
	DecredScriptVersion  *uint32                   `protobuf:"varint,10,opt,name=decred_script_version,json=decredScriptVersion" json:"decred_script_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *TxInputType) Reset()         { *m = TxInputType{} }
func (m *TxInputType) String() string { return proto.CompactTextString(m) }
func (*TxInputType) ProtoMessage()    {}
func (*TxInputType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{4}
}
func (m *TxInputType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxInputType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxInputType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxInputType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxInputType.Merge(dst, src)
}
func (m *TxInputType) XXX_Size() int {
	return m.Size()
}
func (m *TxInputType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxInputType.DiscardUnknown(m)
}

var xxx_messageInfo_TxInputType proto.InternalMessageInfo

const Default_TxInputType_Sequence uint32 = 4294967295
const Default_TxInputType_ScriptType InputScriptType = InputScriptType_SPENDADDRESS

func (m *TxInputType) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *TxInputType) GetPrevHash() []byte {
	if m != nil {
		return m.PrevHash
	}
	return nil
}

func (m *TxInputType) GetPrevIndex() uint32 {
	if m != nil && m.PrevIndex != nil {
		return *m.PrevIndex
	}
	return 0
}

func (m *TxInputType) GetScriptSig() []byte {
	if m != nil {
		return m.ScriptSig
	}
	return nil
}

func (m *TxInputType) GetSequence() uint32 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return Default_TxInputType_Sequence
}

func (m *TxInputType) GetScriptType() InputScriptType {
	if m != nil && m.ScriptType != nil {
		return *m.ScriptType
	}
	return Default_TxInputType_ScriptType
}

func (m *TxInputType) GetMultisig() *MultisigRedeemScriptType {
	if m != nil {
		return m.Multisig
	}
	return nil
}

func (m *TxInputType) GetAmount() uint64 {
	if m != nil && m.Amount != nil {
		return *m.Amount
	}
	return 0
}

func (m *TxInputType) GetDecredTree() uint32 {
	if m != nil && m.DecredTree != nil {
		return *m.DecredTree
	}
	return 0
}

func (m *TxInputType) GetDecredScriptVersion() uint32 {
	if m != nil && m.DecredScriptVersion != nil {
		return *m.DecredScriptVersion
	}
	return 0
}

// *
// Structure representing transaction output
// @used_in SimpleSignTx
// @used_in TransactionType
type TxOutputType struct {
	Address              *string                   `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	AddressN             []uint32                  `protobuf:"varint,2,rep,name=address_n,json=addressN" json:"address_n,omitempty"`
	Amount               *uint64                   `protobuf:"varint,3,req,name=amount" json:"amount,omitempty"`
	ScriptType           *OutputScriptType         `protobuf:"varint,4,req,name=script_type,json=scriptType,enum=OutputScriptType" json:"script_type,omitempty"`
	Multisig             *MultisigRedeemScriptType `protobuf:"bytes,5,opt,name=multisig" json:"multisig,omitempty"`
	OpReturnData         []byte                    `protobuf:"bytes,6,opt,name=op_return_data,json=opReturnData" json:"op_return_data,omitempty"`
	DecredScriptVersion  *uint32                   `protobuf:"varint,7,opt,name=decred_script_version,json=decredScriptVersion" json:"decred_script_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *TxOutputType) Reset()         { *m = TxOutputType{} }
func (m *TxOutputType) String() string { return proto.CompactTextString(m) }
func (*TxOutputType) ProtoMessage()    {}
func (*TxOutputType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{5}
}
func (m *TxOutputType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxOutputType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxOutputType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxOutputType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxOutputType.Merge(dst, src)
}
func (m *TxOutputType) XXX_Size() int {
	return m.Size()
}
func (m *TxOutputType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxOutputType.DiscardUnknown(m)
}

var xxx_messageInfo_TxOutputType proto.InternalMessageInfo

func (m *TxOutputType) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *TxOutputType) GetAddressN() []uint32 {
	if m != nil {
		return m.AddressN
	}
	return nil
}

func (m *TxOutputType) GetAmount() uint64 {
	if m != nil && m.Amount != nil {
		return *m.Amount
	}
	return 0
}

func (m *TxOutputType) GetScriptType() OutputScriptType {
	if m != nil && m.ScriptType != nil {
		return *m.ScriptType
	}
	return OutputScriptType_PAYTOADDRESS
}

func (m *TxOutputType) GetMultisig() *MultisigRedeemScriptType {
	if m != nil {
		return m.Multisig
	}
	return nil
}

func (m *TxOutputType) GetOpReturnData() []byte {
	if m != nil {
		return m.OpReturnData
	}
	return nil
}

func (m *TxOutputType) GetDecredScriptVersion() uint32 {
	if m != nil && m.DecredScriptVersion != nil {
		return *m.DecredScriptVersion
	}
	return 0
}

// *
// Structure representing compiled transaction output
// @used_in TransactionType
type TxOutputBinType struct {
	Amount               *uint64  `protobuf:"varint,1,req,name=amount" json:"amount,omitempty"`
	ScriptPubkey         []byte   `protobuf:"bytes,2,req,name=script_pubkey,json=scriptPubkey" json:"script_pubkey,omitempty"`
	DecredScriptVersion  *uint32  `protobuf:"varint,3,opt,name=decred_script_version,json=decredScriptVersion" json:"decred_script_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxOutputBinType) Reset()         { *m = TxOutputBinType{} }
func (m *TxOutputBinType) String() string { return proto.CompactTextString(m) }
func (*TxOutputBinType) ProtoMessage()    {}
func (*TxOutputBinType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{6}
}
func (m *TxOutputBinType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxOutputBinType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxOutputBinType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxOutputBinType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxOutputBinType.Merge(dst, src)
}
func (m *TxOutputBinType) XXX_Size() int {
	return m.Size()
}
func (m *TxOutputBinType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxOutputBinType.DiscardUnknown(m)
}

var xxx_messageInfo_TxOutputBinType proto.InternalMessageInfo

func (m *TxOutputBinType) GetAmount() uint64 {
	if m != nil && m.Amount != nil {
		return *m.Amount
	}
	return 0
}

func (m *TxOutputBinType) GetScriptPubkey() []byte {
	if m != nil {
		return m.ScriptPubkey
	}
	return nil
}

func (m *TxOutputBinType) GetDecredScriptVersion() uint32 {
	if m != nil && m.DecredScriptVersion != nil {
		return *m.DecredScriptVersion
	}
	return 0
}

// *
// Structure representing transaction
// @used_in SimpleSignTx
type TransactionType struct {
	Version              *uint32            `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	Inputs               []*TxInputType     `protobuf:"bytes,2,rep,name=inputs" json:"inputs,omitempty"`
	BinOutputs           []*TxOutputBinType `protobuf:"bytes,3,rep,name=bin_outputs,json=binOutputs" json:"bin_outputs,omitempty"`
	Outputs              []*TxOutputType    `protobuf:"bytes,5,rep,name=outputs" json:"outputs,omitempty"`
	LockTime             *uint32            `protobuf:"varint,4,opt,name=lock_time,json=lockTime" json:"lock_time,omitempty"`
	InputsCnt            *uint32            `protobuf:"varint,6,opt,name=inputs_cnt,json=inputsCnt" json:"inputs_cnt,omitempty"`
	OutputsCnt           *uint32            `protobuf:"varint,7,opt,name=outputs_cnt,json=outputsCnt" json:"outputs_cnt,omitempty"`
	ExtraData            []byte             `protobuf:"bytes,8,opt,name=extra_data,json=extraData" json:"extra_data,omitempty"`
	ExtraDataLen         *uint32            `protobuf:"varint,9,opt,name=extra_data_len,json=extraDataLen" json:"extra_data_len,omitempty"`
	DecredExpiry         *uint32            `protobuf:"varint,10,opt,name=decred_expiry,json=decredExpiry" json:"decred_expiry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TransactionType) Reset()         { *m = TransactionType{} }
func (m *TransactionType) String() string { return proto.CompactTextString(m) }
func (*TransactionType) ProtoMessage()    {}
func (*TransactionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{7}
}
func (m *TransactionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TransactionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionType.Merge(dst, src)
}
func (m *TransactionType) XXX_Size() int {
	return m.Size()
}
func (m *TransactionType) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionType.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionType proto.InternalMessageInfo

func (m *TransactionType) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *TransactionType) GetInputs() []*TxInputType {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *TransactionType) GetBinOutputs() []*TxOutputBinType {
	if m != nil {
		return m.BinOutputs
	}
	return nil
}

func (m *TransactionType) GetOutputs() []*TxOutputType {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *TransactionType) GetLockTime() uint32 {
	if m != nil && m.LockTime != nil {
		return *m.LockTime
	}
	return 0
}

func (m *TransactionType) GetInputsCnt() uint32 {
	if m != nil && m.InputsCnt != nil {
		return *m.InputsCnt
	}
	return 0
}

func (m *TransactionType) GetOutputsCnt() uint32 {
	if m != nil && m.OutputsCnt != nil {
		return *m.OutputsCnt
	}
	return 0
}

func (m *TransactionType) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *TransactionType) GetExtraDataLen() uint32 {
	if m != nil && m.ExtraDataLen != nil {
		return *m.ExtraDataLen
	}
	return 0
}

func (m *TransactionType) GetDecredExpiry() uint32 {
	if m != nil && m.DecredExpiry != nil {
		return *m.DecredExpiry
	}
	return 0
}

// *
// Structure representing request details
// @used_in TxRequest
type TxRequestDetailsType struct {
	RequestIndex         *uint32  `protobuf:"varint,1,opt,name=request_index,json=requestIndex" json:"request_index,omitempty"`
	TxHash               []byte   `protobuf:"bytes,2,opt,name=tx_hash,json=txHash" json:"tx_hash,omitempty"`
	ExtraDataLen         *uint32  `protobuf:"varint,3,opt,name=extra_data_len,json=extraDataLen" json:"extra_data_len,omitempty"`
	ExtraDataOffset      *uint32  `protobuf:"varint,4,opt,name=extra_data_offset,json=extraDataOffset" json:"extra_data_offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRequestDetailsType) Reset()         { *m = TxRequestDetailsType{} }
func (m *TxRequestDetailsType) String() string { return proto.CompactTextString(m) }
func (*TxRequestDetailsType) ProtoMessage()    {}
func (*TxRequestDetailsType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{8}
}
func (m *TxRequestDetailsType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequestDetailsType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequestDetailsType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxRequestDetailsType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequestDetailsType.Merge(dst, src)
}
func (m *TxRequestDetailsType) XXX_Size() int {
	return m.Size()
}
func (m *TxRequestDetailsType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequestDetailsType.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequestDetailsType proto.InternalMessageInfo

func (m *TxRequestDetailsType) GetRequestIndex() uint32 {
	if m != nil && m.RequestIndex != nil {
		return *m.RequestIndex
	}
	return 0
}

func (m *TxRequestDetailsType) GetTxHash() []byte {
	if m != nil {
		return m.TxHash
	}
	return nil
}

func (m *TxRequestDetailsType) GetExtraDataLen() uint32 {
	if m != nil && m.ExtraDataLen != nil {
		return *m.ExtraDataLen
	}
	return 0
}

func (m *TxRequestDetailsType) GetExtraDataOffset() uint32 {
	if m != nil && m.ExtraDataOffset != nil {
		return *m.ExtraDataOffset
	}
	return 0
}

// *
// Structure representing serialized data
// @used_in TxRequest
type TxRequestSerializedType struct {
	SignatureIndex       *uint32  `protobuf:"varint,1,opt,name=signature_index,json=signatureIndex" json:"signature_index,omitempty"`
	Signature            []byte   `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
	SerializedTx         []byte   `protobuf:"bytes,3,opt,name=serialized_tx,json=serializedTx" json:"serialized_tx,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRequestSerializedType) Reset()         { *m = TxRequestSerializedType{} }
func (m *TxRequestSerializedType) String() string { return proto.CompactTextString(m) }
func (*TxRequestSerializedType) ProtoMessage()    {}
func (*TxRequestSerializedType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{9}
}
func (m *TxRequestSerializedType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequestSerializedType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequestSerializedType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TxRequestSerializedType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequestSerializedType.Merge(dst, src)
}
func (m *TxRequestSerializedType) XXX_Size() int {
	return m.Size()
}
func (m *TxRequestSerializedType) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequestSerializedType.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequestSerializedType proto.InternalMessageInfo

func (m *TxRequestSerializedType) GetSignatureIndex() uint32 {
	if m != nil && m.SignatureIndex != nil {
		return *m.SignatureIndex
	}
	return 0
}

func (m *TxRequestSerializedType) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *TxRequestSerializedType) GetSerializedTx() []byte {
	if m != nil {
		return m.SerializedTx
	}
	return nil
}

// *
// Structure representing identity data
// @used_in IdentityType
type IdentityType struct {
	Proto                *string  `protobuf:"bytes,1,opt,name=proto" json:"proto,omitempty"`
	User                 *string  `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
	Host                 *string  `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	Port                 *string  `protobuf:"bytes,4,opt,name=port" json:"port,omitempty"`
	Path                 *string  `protobuf:"bytes,5,opt,name=path" json:"path,omitempty"`
	Index                *uint32  `protobuf:"varint,6,opt,name=index,def=0" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IdentityType) Reset()         { *m = IdentityType{} }
func (m *IdentityType) String() string { return proto.CompactTextString(m) }
func (*IdentityType) ProtoMessage()    {}
func (*IdentityType) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{10}
}
func (m *IdentityType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdentityType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdentityType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IdentityType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentityType.Merge(dst, src)
}
func (m *IdentityType) XXX_Size() int {
	return m.Size()
}
func (m *IdentityType) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentityType.DiscardUnknown(m)
}

var xxx_messageInfo_IdentityType proto.InternalMessageInfo

const Default_IdentityType_Index uint32 = 0

func (m *IdentityType) GetProto() string {
	if m != nil && m.Proto != nil {
		return *m.Proto
	}
	return ""
}

func (m *IdentityType) GetUser() string {
	if m != nil && m.User != nil {
		return *m.User
	}
	return ""
}

func (m *IdentityType) GetHost() string {
	if m != nil && m.Host != nil {
		return *m.Host
	}
	return ""
}

func (m *IdentityType) GetPort() string {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return ""
}

func (m *IdentityType) GetPath() string {
	if m != nil && m.Path != nil {
		return *m.Path
	}
	return ""
}

func (m *IdentityType) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return Default_IdentityType_Index
}

// *
// Skycoin transaction input
// @used_in TransactionSign
type SkycoinTransactionInput struct {
	HashIn               *string  `protobuf:"bytes,1,req,name=hashIn" json:"hashIn,omitempty"`
	Index                *uint32  `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SkycoinTransactionInput) Reset()         { *m = SkycoinTransactionInput{} }
func (m *SkycoinTransactionInput) String() string { return proto.CompactTextString(m) }
func (*SkycoinTransactionInput) ProtoMessage()    {}
func (*SkycoinTransactionInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{11}
}
func (m *SkycoinTransactionInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkycoinTransactionInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkycoinTransactionInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SkycoinTransactionInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkycoinTransactionInput.Merge(dst, src)
}
func (m *SkycoinTransactionInput) XXX_Size() int {
	return m.Size()
}
func (m *SkycoinTransactionInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SkycoinTransactionInput.DiscardUnknown(m)
}

var xxx_messageInfo_SkycoinTransactionInput proto.InternalMessageInfo

func (m *SkycoinTransactionInput) GetHashIn() string {
	if m != nil && m.HashIn != nil {
		return *m.HashIn
	}
	return ""
}

func (m *SkycoinTransactionInput) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

// *
// Skycoin transaction output
// @used_in TransactionSign
type SkycoinTransactionOutput struct {
	Address              *string  `protobuf:"bytes,1,req,name=address" json:"address,omitempty"`
	Coin                 *uint64  `protobuf:"varint,2,req,name=coin" json:"coin,omitempty"`
	Hour                 *uint64  `protobuf:"varint,3,req,name=hour" json:"hour,omitempty"`
	AddressIndex         *uint32  `protobuf:"varint,4,opt,name=address_index,json=addressIndex" json:"address_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SkycoinTransactionOutput) Reset()         { *m = SkycoinTransactionOutput{} }
func (m *SkycoinTransactionOutput) String() string { return proto.CompactTextString(m) }
func (*SkycoinTransactionOutput) ProtoMessage()    {}
func (*SkycoinTransactionOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{12}
}
func (m *SkycoinTransactionOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkycoinTransactionOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkycoinTransactionOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SkycoinTransactionOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkycoinTransactionOutput.Merge(dst, src)
}
func (m *SkycoinTransactionOutput) XXX_Size() int {
	return m.Size()
}
func (m *SkycoinTransactionOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SkycoinTransactionOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SkycoinTransactionOutput proto.InternalMessageInfo

func (m *SkycoinTransactionOutput) GetAddress() string {
	if m != nil && m.Address != nil {
		return *m.Address
	}
	return ""
}

func (m *SkycoinTransactionOutput) GetCoin() uint64 {
	if m != nil && m.Coin != nil {
		return *m.Coin
	}
	return 0
}

func (m *SkycoinTransactionOutput) GetHour() uint64 {
	if m != nil && m.Hour != nil {
		return *m.Hour
	}
	return 0
}

func (m *SkycoinTransactionOutput) GetAddressIndex() uint32 {
	if m != nil && m.AddressIndex != nil {
		return *m.AddressIndex
	}
	return 0
}

type Bip44AddrIndex struct {
	Purpose              *uint32  `protobuf:"varint,1,req,name=purpose" json:"purpose,omitempty"`
	CoinType             *uint32  `protobuf:"varint,2,req,name=coin_type,json=coinType" json:"coin_type,omitempty"`
	Account              *uint32  `protobuf:"varint,3,req,name=account" json:"account,omitempty"`
	Change               *uint32  `protobuf:"varint,4,req,name=change" json:"change,omitempty"`
	AddressStartIndex    *uint32  `protobuf:"varint,5,req,name=address_start_index,json=addressStartIndex" json:"address_start_index,omitempty"`
	AddressN             *uint32  `protobuf:"varint,6,req,name=address_n,json=addressN" json:"address_n,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Bip44AddrIndex) Reset()         { *m = Bip44AddrIndex{} }
func (m *Bip44AddrIndex) String() string { return proto.CompactTextString(m) }
func (*Bip44AddrIndex) ProtoMessage()    {}
func (*Bip44AddrIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_types_e49f3e51e91bfce8, []int{13}
}
func (m *Bip44AddrIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bip44AddrIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bip44AddrIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Bip44AddrIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bip44AddrIndex.Merge(dst, src)
}
func (m *Bip44AddrIndex) XXX_Size() int {
	return m.Size()
}
func (m *Bip44AddrIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_Bip44AddrIndex.DiscardUnknown(m)
}

var xxx_messageInfo_Bip44AddrIndex proto.InternalMessageInfo

func (m *Bip44AddrIndex) GetPurpose() uint32 {
	if m != nil && m.Purpose != nil {
		return *m.Purpose
	}
	return 0
}

func (m *Bip44AddrIndex) GetCoinType() uint32 {
	if m != nil && m.CoinType != nil {
		return *m.CoinType
	}
	return 0
}

func (m *Bip44AddrIndex) GetAccount() uint32 {
	if m != nil && m.Account != nil {
		return *m.Account
	}
	return 0
}

func (m *Bip44AddrIndex) GetChange() uint32 {
	if m != nil && m.Change != nil {
		return *m.Change
	}
	return 0
}

func (m *Bip44AddrIndex) GetAddressStartIndex() uint32 {
	if m != nil && m.AddressStartIndex != nil {
		return *m.AddressStartIndex
	}
	return 0
}

func (m *Bip44AddrIndex) GetAddressN() uint32 {
	if m != nil && m.AddressN != nil {
		return *m.AddressN
	}
	return 0
}

var E_WireIn = &proto.ExtensionDesc{
	ExtendedType:  (*protobuf.EnumValueOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         50002,
	Name:          "wire_in",
	Tag:           "varint,50002,opt,name=wire_in,json=wireIn",
	Filename:      "types.proto",
}

var E_WireOut = &proto.ExtensionDesc{
	ExtendedType:  (*protobuf.EnumValueOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         50003,
	Name:          "wire_out",
	Tag:           "varint,50003,opt,name=wire_out,json=wireOut",
	Filename:      "types.proto",
}

var E_WireDebugIn = &proto.ExtensionDesc{
	ExtendedType:  (*protobuf.EnumValueOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         50004,
	Name:          "wire_debug_in",
	Tag:           "varint,50004,opt,name=wire_debug_in,json=wireDebugIn",
	Filename:      "types.proto",
}

var E_WireDebugOut = &proto.ExtensionDesc{
	ExtendedType:  (*protobuf.EnumValueOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         50005,
	Name:          "wire_debug_out",
	Tag:           "varint,50005,opt,name=wire_debug_out,json=wireDebugOut",
	Filename:      "types.proto",
}

var E_WireTiny = &proto.ExtensionDesc{
	ExtendedType:  (*protobuf.EnumValueOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         50006,
	Name:          "wire_tiny",
	Tag:           "varint,50006,opt,name=wire_tiny,json=wireTiny",
	Filename:      "types.proto",
}

var E_WireBootloader = &proto.ExtensionDesc{
	ExtendedType:  (*protobuf.EnumValueOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         50007,
	Name:          "wire_bootloader",
	Tag:           "varint,50007,opt,name=wire_bootloader,json=wireBootloader",
	Filename:      "types.proto",
}

func init() {
	proto.RegisterType((*HDNodeType)(nil), "HDNodeType")
	proto.RegisterType((*HDNodePathType)(nil), "HDNodePathType")
	proto.RegisterType((*CoinType)(nil), "CoinType")
	proto.RegisterType((*MultisigRedeemScriptType)(nil), "MultisigRedeemScriptType")
	proto.RegisterType((*TxInputType)(nil), "TxInputType")
	proto.RegisterType((*TxOutputType)(nil), "TxOutputType")
	proto.RegisterType((*TxOutputBinType)(nil), "TxOutputBinType")
	proto.RegisterType((*TransactionType)(nil), "TransactionType")
	proto.RegisterType((*TxRequestDetailsType)(nil), "TxRequestDetailsType")
	proto.RegisterType((*TxRequestSerializedType)(nil), "TxRequestSerializedType")
	proto.RegisterType((*IdentityType)(nil), "IdentityType")
	proto.RegisterType((*SkycoinTransactionInput)(nil), "SkycoinTransactionInput")
	proto.RegisterType((*SkycoinTransactionOutput)(nil), "SkycoinTransactionOutput")
	proto.RegisterType((*Bip44AddrIndex)(nil), "Bip44AddrIndex")
	proto.RegisterEnum("FailureType", FailureType_name, FailureType_value)
	proto.RegisterEnum("OutputScriptType", OutputScriptType_name, OutputScriptType_value)
	proto.RegisterEnum("InputScriptType", InputScriptType_name, InputScriptType_value)
	proto.RegisterEnum("RequestType", RequestType_name, RequestType_value)
	proto.RegisterEnum("ButtonRequestType", ButtonRequestType_name, ButtonRequestType_value)
	proto.RegisterEnum("PinMatrixRequestType", PinMatrixRequestType_name, PinMatrixRequestType_value)
	proto.RegisterEnum("WordRequestType", WordRequestType_name, WordRequestType_value)
	proto.RegisterEnum("FirmwareFeatures", FirmwareFeatures_name, FirmwareFeatures_value)
	proto.RegisterEnum("SkycoinAddressType", SkycoinAddressType_name, SkycoinAddressType_value)
	proto.RegisterExtension(E_WireIn)
	proto.RegisterExtension(E_WireOut)
	proto.RegisterExtension(E_WireDebugIn)
	proto.RegisterExtension(E_WireDebugOut)
	proto.RegisterExtension(E_WireTiny)
	proto.RegisterExtension(E_WireBootloader)
}
func (m *HDNodeType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDNodeType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Depth == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("depth")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Depth))
	}
	if m.Fingerprint == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("fingerprint")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Fingerprint))
	}
	if m.ChildNum == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("child_num")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.ChildNum))
	}
	if m.ChainCode == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("chain_code")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChainCode)))
		i += copy(dAtA[i:], m.ChainCode)
	}
	if m.PrivateKey != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrivateKey)))
		i += copy(dAtA[i:], m.PrivateKey)
	}
	if m.PublicKey != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HDNodePathType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HDNodePathType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Node == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("node")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Node.Size()))
		n1, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.AddressN) > 0 {
		for _, num := range m.AddressN {
			dAtA[i] = 0x10
			i++
			i = encodeVarintTypes(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CoinType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoinType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CoinName != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.CoinName)))
		i += copy(dAtA[i:], *m.CoinName)
	}
	if m.CoinShortcut != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.CoinShortcut)))
		i += copy(dAtA[i:], *m.CoinShortcut)
	}
	if m.AddressType != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.AddressType))
	}
	if m.MaxfeeKb != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.MaxfeeKb))
	}
	if m.AddressTypeP2Sh != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.AddressTypeP2Sh))
	}
	if m.SignedMessageHeader != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.SignedMessageHeader)))
		i += copy(dAtA[i:], *m.SignedMessageHeader)
	}
	if m.XpubMagic != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.XpubMagic))
	}
	if m.XprvMagic != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.XprvMagic))
	}
	if m.Segwit != nil {
		dAtA[i] = 0x58
		i++
		if *m.Segwit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Forkid != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Forkid))
	}
	if m.ForceBip143 != nil {
		dAtA[i] = 0x68
		i++
		if *m.ForceBip143 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MultisigRedeemScriptType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultisigRedeemScriptType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pubkeys) > 0 {
		for _, msg := range m.Pubkeys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Signatures) > 0 {
		for _, b := range m.Signatures {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.M != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.M))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxInputType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxInputType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AddressN) > 0 {
		for _, num := range m.AddressN {
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(num))
		}
	}
	if m.PrevHash == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("prev_hash")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PrevHash)))
		i += copy(dAtA[i:], m.PrevHash)
	}
	if m.PrevIndex == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("prev_index")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.PrevIndex))
	}
	if m.ScriptSig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ScriptSig)))
		i += copy(dAtA[i:], m.ScriptSig)
	}
	if m.Sequence != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Sequence))
	}
	if m.ScriptType != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.ScriptType))
	}
	if m.Multisig != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Multisig.Size()))
		n2, err := m.Multisig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Amount != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Amount))
	}
	if m.DecredTree != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.DecredTree))
	}
	if m.DecredScriptVersion != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.DecredScriptVersion))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxOutputType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxOutputType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.Address)))
		i += copy(dAtA[i:], *m.Address)
	}
	if len(m.AddressN) > 0 {
		for _, num := range m.AddressN {
			dAtA[i] = 0x10
			i++
			i = encodeVarintTypes(dAtA, i, uint64(num))
		}
	}
	if m.Amount == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("amount")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Amount))
	}
	if m.ScriptType == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("script_type")
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.ScriptType))
	}
	if m.Multisig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Multisig.Size()))
		n3, err := m.Multisig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.OpReturnData != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OpReturnData)))
		i += copy(dAtA[i:], m.OpReturnData)
	}
	if m.DecredScriptVersion != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.DecredScriptVersion))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxOutputBinType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxOutputBinType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Amount == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("amount")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Amount))
	}
	if m.ScriptPubkey == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("script_pubkey")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ScriptPubkey)))
		i += copy(dAtA[i:], m.ScriptPubkey)
	}
	if m.DecredScriptVersion != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.DecredScriptVersion))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Version))
	}
	if len(m.Inputs) > 0 {
		for _, msg := range m.Inputs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BinOutputs) > 0 {
		for _, msg := range m.BinOutputs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LockTime != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.LockTime))
	}
	if len(m.Outputs) > 0 {
		for _, msg := range m.Outputs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.InputsCnt != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.InputsCnt))
	}
	if m.OutputsCnt != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.OutputsCnt))
	}
	if m.ExtraData != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ExtraData)))
		i += copy(dAtA[i:], m.ExtraData)
	}
	if m.ExtraDataLen != nil {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.ExtraDataLen))
	}
	if m.DecredExpiry != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.DecredExpiry))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxRequestDetailsType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequestDetailsType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestIndex != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.RequestIndex))
	}
	if m.TxHash != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TxHash)))
		i += copy(dAtA[i:], m.TxHash)
	}
	if m.ExtraDataLen != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.ExtraDataLen))
	}
	if m.ExtraDataOffset != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.ExtraDataOffset))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxRequestSerializedType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequestSerializedType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SignatureIndex != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.SignatureIndex))
	}
	if m.Signature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.SerializedTx != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SerializedTx)))
		i += copy(dAtA[i:], m.SerializedTx)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IdentityType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentityType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Proto != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.Proto)))
		i += copy(dAtA[i:], *m.Proto)
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.User)))
		i += copy(dAtA[i:], *m.User)
	}
	if m.Host != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.Host)))
		i += copy(dAtA[i:], *m.Host)
	}
	if m.Port != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.Port)))
		i += copy(dAtA[i:], *m.Port)
	}
	if m.Path != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.Path)))
		i += copy(dAtA[i:], *m.Path)
	}
	if m.Index != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Index))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SkycoinTransactionInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkycoinTransactionInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HashIn == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("hashIn")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.HashIn)))
		i += copy(dAtA[i:], *m.HashIn)
	}
	if m.Index != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Index))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SkycoinTransactionOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkycoinTransactionOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Address == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("address")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(*m.Address)))
		i += copy(dAtA[i:], *m.Address)
	}
	if m.Coin == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("coin")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Coin))
	}
	if m.Hour == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("hour")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Hour))
	}
	if m.AddressIndex != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.AddressIndex))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Bip44AddrIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bip44AddrIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Purpose == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("purpose")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Purpose))
	}
	if m.CoinType == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("coin_type")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.CoinType))
	}
	if m.Account == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("account")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Account))
	}
	if m.Change == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("change")
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.Change))
	}
	if m.AddressStartIndex == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("address_start_index")
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.AddressStartIndex))
	}
	if m.AddressN == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("address_n")
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTypes(dAtA, i, uint64(*m.AddressN))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HDNodeType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Depth != nil {
		n += 1 + sovTypes(uint64(*m.Depth))
	}
	if m.Fingerprint != nil {
		n += 1 + sovTypes(uint64(*m.Fingerprint))
	}
	if m.ChildNum != nil {
		n += 1 + sovTypes(uint64(*m.ChildNum))
	}
	if m.ChainCode != nil {
		l = len(m.ChainCode)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrivateKey != nil {
		l = len(m.PrivateKey)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PublicKey != nil {
		l = len(m.PublicKey)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HDNodePathType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AddressN) > 0 {
		for _, e := range m.AddressN {
			n += 1 + sovTypes(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CoinType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CoinName != nil {
		l = len(*m.CoinName)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CoinShortcut != nil {
		l = len(*m.CoinShortcut)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AddressType != nil {
		n += 1 + sovTypes(uint64(*m.AddressType))
	}
	if m.MaxfeeKb != nil {
		n += 1 + sovTypes(uint64(*m.MaxfeeKb))
	}
	if m.AddressTypeP2Sh != nil {
		n += 1 + sovTypes(uint64(*m.AddressTypeP2Sh))
	}
	if m.SignedMessageHeader != nil {
		l = len(*m.SignedMessageHeader)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XpubMagic != nil {
		n += 1 + sovTypes(uint64(*m.XpubMagic))
	}
	if m.XprvMagic != nil {
		n += 1 + sovTypes(uint64(*m.XprvMagic))
	}
	if m.Segwit != nil {
		n += 2
	}
	if m.Forkid != nil {
		n += 1 + sovTypes(uint64(*m.Forkid))
	}
	if m.ForceBip143 != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultisigRedeemScriptType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pubkeys) > 0 {
		for _, e := range m.Pubkeys {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Signatures) > 0 {
		for _, b := range m.Signatures {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.M != nil {
		n += 1 + sovTypes(uint64(*m.M))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxInputType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AddressN) > 0 {
		for _, e := range m.AddressN {
			n += 1 + sovTypes(uint64(e))
		}
	}
	if m.PrevHash != nil {
		l = len(m.PrevHash)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PrevIndex != nil {
		n += 1 + sovTypes(uint64(*m.PrevIndex))
	}
	if m.ScriptSig != nil {
		l = len(m.ScriptSig)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Sequence != nil {
		n += 1 + sovTypes(uint64(*m.Sequence))
	}
	if m.ScriptType != nil {
		n += 1 + sovTypes(uint64(*m.ScriptType))
	}
	if m.Multisig != nil {
		l = m.Multisig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Amount != nil {
		n += 1 + sovTypes(uint64(*m.Amount))
	}
	if m.DecredTree != nil {
		n += 1 + sovTypes(uint64(*m.DecredTree))
	}
	if m.DecredScriptVersion != nil {
		n += 1 + sovTypes(uint64(*m.DecredScriptVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxOutputType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = len(*m.Address)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AddressN) > 0 {
		for _, e := range m.AddressN {
			n += 1 + sovTypes(uint64(e))
		}
	}
	if m.Amount != nil {
		n += 1 + sovTypes(uint64(*m.Amount))
	}
	if m.ScriptType != nil {
		n += 1 + sovTypes(uint64(*m.ScriptType))
	}
	if m.Multisig != nil {
		l = m.Multisig.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OpReturnData != nil {
		l = len(m.OpReturnData)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DecredScriptVersion != nil {
		n += 1 + sovTypes(uint64(*m.DecredScriptVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxOutputBinType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != nil {
		n += 1 + sovTypes(uint64(*m.Amount))
	}
	if m.ScriptPubkey != nil {
		l = len(m.ScriptPubkey)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DecredScriptVersion != nil {
		n += 1 + sovTypes(uint64(*m.DecredScriptVersion))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		n += 1 + sovTypes(uint64(*m.Version))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.BinOutputs) > 0 {
		for _, e := range m.BinOutputs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.LockTime != nil {
		n += 1 + sovTypes(uint64(*m.LockTime))
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.InputsCnt != nil {
		n += 1 + sovTypes(uint64(*m.InputsCnt))
	}
	if m.OutputsCnt != nil {
		n += 1 + sovTypes(uint64(*m.OutputsCnt))
	}
	if m.ExtraData != nil {
		l = len(m.ExtraData)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExtraDataLen != nil {
		n += 1 + sovTypes(uint64(*m.ExtraDataLen))
	}
	if m.DecredExpiry != nil {
		n += 1 + sovTypes(uint64(*m.DecredExpiry))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxRequestDetailsType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestIndex != nil {
		n += 1 + sovTypes(uint64(*m.RequestIndex))
	}
	if m.TxHash != nil {
		l = len(m.TxHash)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExtraDataLen != nil {
		n += 1 + sovTypes(uint64(*m.ExtraDataLen))
	}
	if m.ExtraDataOffset != nil {
		n += 1 + sovTypes(uint64(*m.ExtraDataOffset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxRequestSerializedType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SignatureIndex != nil {
		n += 1 + sovTypes(uint64(*m.SignatureIndex))
	}
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SerializedTx != nil {
		l = len(m.SerializedTx)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IdentityType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Proto != nil {
		l = len(*m.Proto)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.User != nil {
		l = len(*m.User)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Host != nil {
		l = len(*m.Host)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Port != nil {
		l = len(*m.Port)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Path != nil {
		l = len(*m.Path)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Index != nil {
		n += 1 + sovTypes(uint64(*m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SkycoinTransactionInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HashIn != nil {
		l = len(*m.HashIn)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Index != nil {
		n += 1 + sovTypes(uint64(*m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SkycoinTransactionOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Address != nil {
		l = len(*m.Address)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Coin != nil {
		n += 1 + sovTypes(uint64(*m.Coin))
	}
	if m.Hour != nil {
		n += 1 + sovTypes(uint64(*m.Hour))
	}
	if m.AddressIndex != nil {
		n += 1 + sovTypes(uint64(*m.AddressIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Bip44AddrIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Purpose != nil {
		n += 1 + sovTypes(uint64(*m.Purpose))
	}
	if m.CoinType != nil {
		n += 1 + sovTypes(uint64(*m.CoinType))
	}
	if m.Account != nil {
		n += 1 + sovTypes(uint64(*m.Account))
	}
	if m.Change != nil {
		n += 1 + sovTypes(uint64(*m.Change))
	}
	if m.AddressStartIndex != nil {
		n += 1 + sovTypes(uint64(*m.AddressStartIndex))
	}
	if m.AddressN != nil {
		n += 1 + sovTypes(uint64(*m.AddressN))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HDNodeType) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDNodeType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDNodeType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depth", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Depth = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fingerprint = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildNum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChildNum = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainCode", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainCode = append(m.ChainCode[:0], dAtA[iNdEx:postIndex]...)
			if m.ChainCode == nil {
				m.ChainCode = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = append(m.PrivateKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivateKey == nil {
				m.PrivateKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("depth")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("fingerprint")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("child_num")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("chain_code")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HDNodePathType) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HDNodePathType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HDNodePathType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &HDNodeType{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddressN = append(m.AddressN, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AddressN) == 0 {
					m.AddressN = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddressN = append(m.AddressN, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressN", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("node")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoinType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoinType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoinType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CoinName = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinShortcut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CoinShortcut = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddressType = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxfeeKb", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MaxfeeKb = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressTypeP2Sh", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddressTypeP2Sh = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedMessageHeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SignedMessageHeader = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XpubMagic", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XpubMagic = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XprvMagic", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XprvMagic = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Segwit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Segwit = &b
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forkid", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Forkid = &v
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceBip143", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ForceBip143 = &b
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultisigRedeemScriptType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultisigRedeemScriptType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultisigRedeemScriptType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pubkeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pubkeys = append(m.Pubkeys, &HDNodePathType{})
			if err := m.Pubkeys[len(m.Pubkeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, make([]byte, postIndex-iNdEx))
			copy(m.Signatures[len(m.Signatures)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.M = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxInputType) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxInputType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxInputType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddressN = append(m.AddressN, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AddressN) == 0 {
					m.AddressN = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddressN = append(m.AddressN, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressN", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevHash = append(m.PrevHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PrevHash == nil {
				m.PrevHash = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrevIndex = &v
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptSig = append(m.ScriptSig[:0], dAtA[iNdEx:postIndex]...)
			if m.ScriptSig == nil {
				m.ScriptSig = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sequence = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptType", wireType)
			}
			var v InputScriptType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (InputScriptType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScriptType = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multisig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Multisig == nil {
				m.Multisig = &MultisigRedeemScriptType{}
			}
			if err := m.Multisig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Amount = &v
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecredTree", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecredTree = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecredScriptVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecredScriptVersion = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("prev_hash")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("prev_index")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxOutputType) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxOutputType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxOutputType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Address = &s
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AddressN = append(m.AddressN, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AddressN) == 0 {
					m.AddressN = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AddressN = append(m.AddressN, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressN", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Amount = &v
			hasFields[0] |= uint64(0x00000001)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptType", wireType)
			}
			var v OutputScriptType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (OutputScriptType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScriptType = &v
			hasFields[0] |= uint64(0x00000002)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multisig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Multisig == nil {
				m.Multisig = &MultisigRedeemScriptType{}
			}
			if err := m.Multisig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpReturnData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpReturnData = append(m.OpReturnData[:0], dAtA[iNdEx:postIndex]...)
			if m.OpReturnData == nil {
				m.OpReturnData = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecredScriptVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecredScriptVersion = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("amount")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("script_type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxOutputBinType) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxOutputBinType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxOutputBinType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Amount = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptPubkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScriptPubkey = append(m.ScriptPubkey[:0], dAtA[iNdEx:postIndex]...)
			if m.ScriptPubkey == nil {
				m.ScriptPubkey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecredScriptVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecredScriptVersion = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("amount")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("script_pubkey")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Version = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &TxInputType{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinOutputs = append(m.BinOutputs, &TxOutputBinType{})
			if err := m.BinOutputs[len(m.BinOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockTime", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LockTime = &v
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, &TxOutputType{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputsCnt", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InputsCnt = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputsCnt", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputsCnt = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtraData = append(m.ExtraData[:0], dAtA[iNdEx:postIndex]...)
			if m.ExtraData == nil {
				m.ExtraData = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraDataLen", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExtraDataLen = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecredExpiry", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DecredExpiry = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRequestDetailsType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequestDetailsType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequestDetailsType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestIndex = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraDataLen", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExtraDataLen = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraDataOffset", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExtraDataOffset = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRequestSerializedType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequestSerializedType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequestSerializedType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SignatureIndex = &v
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerializedTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerializedTx = append(m.SerializedTx[:0], dAtA[iNdEx:postIndex]...)
			if m.SerializedTx == nil {
				m.SerializedTx = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentityType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentityType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentityType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Proto = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.User = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Host = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Port = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Path = &s
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkycoinTransactionInput) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkycoinTransactionInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkycoinTransactionInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HashIn = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("hashIn")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkycoinTransactionOutput) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkycoinTransactionOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkycoinTransactionOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Address = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Coin = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hour", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hour = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddressIndex = &v
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("address")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("coin")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("hour")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Bip44AddrIndex) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bip44AddrIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bip44AddrIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purpose = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoinType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CoinType = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Account = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Change = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressStartIndex", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddressStartIndex = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressN", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AddressN = &v
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("purpose")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("coin_type")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("account")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("change")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("address_start_index")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("address_n")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("types.proto", fileDescriptor_types_e49f3e51e91bfce8) }

var fileDescriptor_types_e49f3e51e91bfce8 = []byte{
	// 2304 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x58, 0xcb, 0x73, 0x1b, 0x49,
	0x19, 0xcf, 0x48, 0xb2, 0x2d, 0x7d, 0x92, 0xec, 0x4e, 0xe7, 0xe1, 0xc9, 0x6e, 0x1e, 0x8a, 0x13,
	0x76, 0x8d, 0xab, 0xd0, 0xee, 0x6a, 0xf3, 0x20, 0x2e, 0x0a, 0xf0, 0x43, 0x8e, 0x55, 0x1b, 0xcb,
	0xaa, 0xd1, 0x64, 0xd7, 0x70, 0x99, 0x1a, 0xcd, 0xb4, 0xa5, 0x2e, 0x8f, 0x7a, 0x86, 0x9e, 0x1e,
	0x47, 0xe2, 0x42, 0x41, 0x15, 0x70, 0xe2, 0xc2, 0x85, 0x3b, 0x05, 0xfc, 0x1d, 0x9c, 0x80, 0x23,
	0xc5, 0xf3, 0x4a, 0xed, 0xdf, 0xc0, 0x1f, 0x40, 0xf5, 0x63, 0x64, 0xc9, 0x89, 0xa9, 0xdc, 0xd4,
	0xbf, 0xdf, 0xd7, 0x5f, 0x7f, 0xef, 0x6e, 0x0d, 0x54, 0xc5, 0x34, 0x21, 0x69, 0x33, 0xe1, 0xb1,
	0x88, 0x3f, 0x68, 0x0c, 0xe3, 0x78, 0x18, 0x91, 0x4f, 0xd4, 0x6a, 0x90, 0x9d, 0x7e, 0x12, 0x92,
	0x34, 0xe0, 0x34, 0x11, 0x31, 0xd7, 0x12, 0x1b, 0x7f, 0xb4, 0x00, 0x0e, 0xf7, 0xbb, 0x71, 0x48,
	0xdc, 0x69, 0x42, 0xf0, 0x4d, 0x58, 0x0a, 0x49, 0x22, 0x46, 0xb6, 0xd5, 0x28, 0x6c, 0xd6, 0x1d,
	0xbd, 0xc0, 0x0d, 0xa8, 0x9e, 0x52, 0x36, 0x24, 0x3c, 0xe1, 0x94, 0x09, 0xbb, 0xa0, 0xb8, 0x79,
	0x08, 0x7f, 0x08, 0x95, 0x60, 0x44, 0xa3, 0xd0, 0x63, 0xd9, 0xd8, 0x2e, 0x2a, 0xbe, 0xac, 0x80,
	0x6e, 0x36, 0xc6, 0xf7, 0x00, 0x82, 0x91, 0x4f, 0x99, 0x17, 0xc4, 0x21, 0xb1, 0x4b, 0x8d, 0xc2,
	0x66, 0xcd, 0xa9, 0x28, 0x64, 0x2f, 0x0e, 0x09, 0x7e, 0x00, 0xd5, 0x84, 0xd3, 0x73, 0x5f, 0x10,
	0xef, 0x8c, 0x4c, 0xed, 0xa5, 0x86, 0xb5, 0x59, 0x73, 0xc0, 0x40, 0x5f, 0x90, 0xa9, 0xdc, 0x9f,
	0x64, 0x83, 0x88, 0x06, 0x8a, 0x5f, 0x56, 0x7c, 0x45, 0x23, 0x5f, 0x90, 0xe9, 0x46, 0x17, 0x56,
	0xb5, 0x07, 0x3d, 0x5f, 0x8c, 0x94, 0x17, 0x0f, 0xa0, 0xc4, 0xe4, 0x51, 0xd2, 0x89, 0x6a, 0xab,
	0xda, 0xbc, 0x70, 0xd0, 0x51, 0x84, 0x34, 0xd7, 0x0f, 0x43, 0x4e, 0xd2, 0xd4, 0x63, 0x76, 0xa1,
	0x51, 0x94, 0xe6, 0x1a, 0xa0, 0xbb, 0xf1, 0x9b, 0x22, 0x94, 0xf7, 0x62, 0xca, 0x94, 0x2a, 0xe9,
	0x58, 0x4c, 0x99, 0xc7, 0xfc, 0xb1, 0xd4, 0x67, 0x6d, 0x56, 0x9c, 0xb2, 0x04, 0xba, 0xfe, 0x98,
	0xe0, 0x47, 0x50, 0x57, 0x64, 0x3a, 0x8a, 0xb9, 0x08, 0x32, 0x19, 0x19, 0x29, 0x50, 0x93, 0x60,
	0xdf, 0x60, 0xf8, 0x31, 0xd4, 0xf2, 0xb3, 0x64, 0x6a, 0xec, 0x62, 0xc3, 0xda, 0xac, 0x6f, 0x5b,
	0x9f, 0x3a, 0x55, 0x03, 0xe7, 0xe7, 0x8c, 0xfd, 0xc9, 0x29, 0x21, 0xde, 0xd9, 0xc0, 0x2e, 0x35,
	0xac, 0xcd, 0x92, 0x53, 0xd6, 0xc0, 0x17, 0x03, 0xfc, 0x2d, 0xb8, 0x3e, 0xaf, 0xc2, 0x4b, 0x5a,
	0xe9, 0x48, 0xc5, 0xa9, 0xbe, 0x6d, 0x3d, 0x75, 0xd6, 0xe6, 0xf4, 0xf4, 0x5a, 0xe9, 0x08, 0xb7,
	0xe0, 0x56, 0x4a, 0x87, 0x8c, 0x84, 0xde, 0x98, 0xa4, 0xa9, 0x3f, 0x24, 0xde, 0x88, 0xf8, 0x21,
	0xe1, 0x76, 0x59, 0x99, 0x77, 0x43, 0x93, 0x47, 0x9a, 0x3b, 0x54, 0x14, 0xfe, 0x18, 0x60, 0x92,
	0x64, 0x03, 0x6f, 0xec, 0x0f, 0x69, 0x60, 0x57, 0x94, 0xee, 0xf2, 0xf3, 0x67, 0x9f, 0x3e, 0x7b,
	0xfe, 0xf9, 0xd3, 0x6f, 0x3b, 0x15, 0xc9, 0x1d, 0x49, 0x4a, 0x0b, 0xf2, 0x73, 0x23, 0x08, 0x17,
	0x82, 0xcf, 0x5a, 0xcf, 0x9f, 0x49, 0x41, 0x7e, 0xae, 0x05, 0x6f, 0xc3, 0x72, 0x4a, 0x86, 0x6f,
	0xa8, 0xb0, 0xab, 0x0d, 0x6b, 0xb3, 0xec, 0x98, 0x95, 0xc4, 0x4f, 0x63, 0x7e, 0x46, 0x43, 0xbb,
	0x26, 0x37, 0x3b, 0x66, 0x85, 0x1f, 0x42, 0xed, 0x34, 0xe6, 0x01, 0xf1, 0x06, 0x34, 0xf9, 0xec,
	0xc9, 0xe7, 0x76, 0x5d, 0xed, 0xaa, 0x2a, 0x6c, 0x57, 0x41, 0x1b, 0x29, 0xd8, 0x47, 0x59, 0x24,
	0x68, 0x4a, 0x87, 0x0e, 0x09, 0x09, 0x19, 0xf7, 0x55, 0x31, 0xab, 0x00, 0x7e, 0x13, 0x56, 0x92,
	0x6c, 0x70, 0x46, 0xa6, 0xa9, 0x6d, 0x35, 0x8a, 0x9b, 0xd5, 0xd6, 0x5a, 0x73, 0xb1, 0x2a, 0x9c,
	0x9c, 0xc7, 0xf7, 0x01, 0x64, 0x08, 0x7c, 0x91, 0x71, 0x92, 0xaa, 0xf4, 0xd7, 0x9c, 0x39, 0x04,
	0xd7, 0xc0, 0x1a, 0xeb, 0x34, 0x39, 0xd6, 0x78, 0xe3, 0xd7, 0x45, 0xa8, 0xba, 0x93, 0x0e, 0x4b,
	0x32, 0x91, 0x67, 0xea, 0xa2, 0x76, 0xac, 0xc5, 0xda, 0x91, 0x64, 0xc2, 0xc9, 0xb9, 0x37, 0xf2,
	0xd3, 0x91, 0xea, 0x93, 0x9a, 0x53, 0x96, 0xc0, 0xa1, 0x9f, 0x8e, 0x54, 0x1d, 0x4b, 0x92, 0xb2,
	0x90, 0x4c, 0x4c, 0x97, 0x28, 0xf1, 0x8e, 0x04, 0x24, 0xad, 0x9b, 0xd3, 0x4b, 0xe9, 0x50, 0xd5,
	0x40, 0xcd, 0xa9, 0x68, 0xa4, 0x4f, 0x87, 0xf8, 0x23, 0x28, 0xa7, 0xe4, 0x47, 0x19, 0x61, 0x01,
	0x31, 0xb9, 0x87, 0x27, 0xad, 0x17, 0x4f, 0x5e, 0x3c, 0x7b, 0xde, 0x7a, 0xf1, 0xd4, 0x99, 0x71,
	0xf8, 0x7b, 0x50, 0x35, 0x6a, 0x54, 0xb9, 0xc9, 0x76, 0x59, 0x6d, 0xa1, 0xa6, 0x72, 0xe0, 0x22,
	0x5e, 0xdb, 0xb5, 0x7e, 0xaf, 0xdd, 0xdd, 0xdf, 0xd9, 0xdf, 0x77, 0xda, 0xfd, 0xbe, 0x63, 0x4e,
	0x56, 0x0e, 0x3e, 0x85, 0xf2, 0xd8, 0x44, 0xd9, 0x5e, 0x69, 0x58, 0x9b, 0xd5, 0xd6, 0x9d, 0xe6,
	0x55, 0x61, 0x77, 0x66, 0xa2, 0x32, 0xaf, 0xfe, 0x38, 0xce, 0x98, 0x50, 0x65, 0x56, 0x72, 0xcc,
	0x4a, 0xb6, 0x77, 0x48, 0x02, 0x4e, 0x42, 0x4f, 0x70, 0x42, 0x74, 0x69, 0x39, 0xa0, 0x21, 0x97,
	0x13, 0x22, 0xcb, 0xd5, 0x08, 0x18, 0xbb, 0xcf, 0x09, 0x4f, 0x69, 0xcc, 0x74, 0x71, 0x39, 0x37,
	0x34, 0xa9, 0xcf, 0xfc, 0x52, 0x53, 0x1b, 0xbf, 0x2d, 0x40, 0xcd, 0x9d, 0x1c, 0x67, 0x22, 0xcf,
	0x8a, 0x0d, 0x2b, 0x26, 0x09, 0xa6, 0x4b, 0xf3, 0xe5, 0xff, 0xed, 0xf5, 0x39, 0xa3, 0x65, 0x3a,
	0x2e, 0x8c, 0x6e, 0x2d, 0x06, 0x51, 0xce, 0xac, 0xd5, 0xd6, 0xf5, 0xa6, 0x3e, 0x70, 0xce, 0xfd,
	0xab, 0xe2, 0xb6, 0xf4, 0xfe, 0x71, 0x7b, 0x0c, 0xab, 0x71, 0xe2, 0x71, 0x22, 0x32, 0xce, 0xbc,
	0xd0, 0x17, 0xbe, 0x99, 0x70, 0xb5, 0x38, 0x71, 0x14, 0xb8, 0xef, 0x0b, 0xff, 0xea, 0x20, 0xad,
	0x5c, 0x1d, 0xa4, 0x9f, 0x59, 0xb0, 0x96, 0x07, 0x69, 0xd7, 0xcc, 0xb3, 0x0b, 0x87, 0xad, 0x05,
	0x87, 0x1f, 0x41, 0xdd, 0x28, 0xd6, 0x5d, 0x62, 0x8a, 0xb7, 0xa6, 0xc1, 0x9e, 0xc2, 0xae, 0x36,
	0xa2, 0x78, 0xb5, 0x11, 0xff, 0x2d, 0xc0, 0x9a, 0xcb, 0x7d, 0x96, 0xfa, 0x81, 0xa0, 0x31, 0xcb,
	0x93, 0x95, 0xef, 0xb4, 0xd4, 0xce, 0x7c, 0x89, 0x1f, 0xc3, 0x32, 0x95, 0x85, 0xaa, 0xdb, 0xb2,
	0xda, 0xaa, 0x35, 0xe7, 0x5a, 0xcf, 0x31, 0x1c, 0xfe, 0x0c, 0xaa, 0x03, 0xca, 0xbc, 0x58, 0x79,
	0x96, 0xda, 0x45, 0x25, 0x8a, 0x9a, 0x97, 0x7c, 0x75, 0x60, 0x40, 0x99, 0x46, 0x54, 0x15, 0x44,
	0x71, 0x70, 0xe6, 0x09, 0x3a, 0x26, 0xaa, 0xb7, 0xea, 0x4e, 0x59, 0x02, 0x2e, 0x1d, 0x13, 0xfc,
	0x31, 0xac, 0xe4, 0xba, 0x96, 0x94, 0xae, 0x7a, 0x73, 0xbe, 0xb8, 0x9c, 0x9c, 0x95, 0x2d, 0xaa,
	0x4d, 0xf0, 0x02, 0x26, 0x54, 0x9e, 0xea, 0x4e, 0x45, 0x23, 0x7b, 0xba, 0xd4, 0x8d, 0xa4, 0xe2,
	0x75, 0x6a, 0xc0, 0x40, 0x52, 0xe0, 0x1e, 0x00, 0x99, 0x08, 0xee, 0xeb, 0x3c, 0x97, 0x75, 0x8b,
	0x2b, 0x44, 0x25, 0xf9, 0x31, 0xac, 0x5e, 0xd0, 0x5e, 0x44, 0x98, 0xe9, 0x96, 0xda, 0x4c, 0xe4,
	0x15, 0x61, 0x32, 0x55, 0x26, 0x0b, 0x64, 0x92, 0x50, 0x3e, 0x35, 0x7d, 0x52, 0xd3, 0x60, 0x5b,
	0x61, 0x1b, 0x7f, 0xb0, 0xe0, 0xa6, 0x3b, 0x71, 0xe4, 0x50, 0x48, 0xc5, 0x3e, 0x11, 0x3e, 0x8d,
	0xf4, 0x45, 0xf3, 0x08, 0xea, 0x5c, 0xa3, 0x66, 0x0e, 0xe9, 0x0c, 0xd4, 0x0c, 0xa8, 0x47, 0xd1,
	0x3a, 0xac, 0x88, 0x49, 0x3e, 0xc4, 0xa4, 0x91, 0xcb, 0x62, 0xa2, 0x46, 0xd8, 0xdb, 0x16, 0x16,
	0xdf, 0x61, 0xe1, 0x16, 0x5c, 0x9f, 0x93, 0x8a, 0x4f, 0x4f, 0x53, 0x22, 0x4c, 0xd0, 0xd7, 0x66,
	0x82, 0xc7, 0x0a, 0xde, 0xf8, 0xb9, 0x05, 0xeb, 0x33, 0x43, 0xfb, 0x84, 0x53, 0x3f, 0xa2, 0x3f,
	0x26, 0xa1, 0xb2, 0xf5, 0x63, 0x58, 0x9b, 0x8d, 0xe5, 0x05, 0x6b, 0x57, 0x67, 0xb0, 0xb6, 0xf7,
	0x2e, 0x54, 0x66, 0x88, 0xb1, 0xf8, 0x02, 0x50, 0xb5, 0x3d, 0x53, 0xec, 0x89, 0x89, 0xb2, 0x59,
	0xd6, 0xf6, 0xc5, 0x69, 0x93, 0x8d, 0x5f, 0x59, 0x50, 0xeb, 0x84, 0x84, 0x09, 0x2a, 0xa6, 0xf9,
	0x53, 0x48, 0x3d, 0x91, 0xcc, 0x3c, 0xd1, 0x0b, 0x8c, 0xa1, 0x94, 0xa5, 0x84, 0x9b, 0x9b, 0x5e,
	0xfd, 0x96, 0xd8, 0x28, 0x4e, 0x85, 0x52, 0x5b, 0x71, 0xd4, 0x6f, 0x89, 0x25, 0x31, 0xd7, 0x5e,
	0x57, 0x1c, 0xf5, 0x5b, 0x61, 0xbe, 0xd0, 0x37, 0xb7, 0xc4, 0x7c, 0x31, 0xc2, 0xeb, 0xb0, 0xa4,
	0x1d, 0x5b, 0xce, 0x9f, 0x05, 0x7a, 0xbd, 0xf1, 0x12, 0xd6, 0xfb, 0x67, 0x53, 0xf9, 0x92, 0x98,
	0xeb, 0x1e, 0xd5, 0x0a, 0xb2, 0x87, 0x65, 0x6a, 0x3a, 0x4c, 0xf5, 0x70, 0xc5, 0x31, 0x2b, 0x69,
	0xb1, 0xd6, 0x55, 0x50, 0x41, 0x32, 0x8a, 0x7e, 0x6a, 0x81, 0xfd, 0xb6, 0x26, 0x5d, 0xdd, 0x8b,
	0x63, 0xb3, 0x30, 0x3f, 0x36, 0x31, 0x94, 0xe4, 0x16, 0x35, 0x07, 0x4a, 0x8e, 0xfa, 0xad, 0x1d,
	0xcd, 0xb8, 0x99, 0x95, 0xea, 0xb7, 0x0c, 0x6e, 0x3e, 0x5e, 0xf5, 0xe1, 0x3a, 0xcf, 0xf9, 0x9b,
	0x47, 0xe5, 0x67, 0xe3, 0x4f, 0x16, 0xac, 0xee, 0xd2, 0xe4, 0xc9, 0x93, 0x9d, 0x30, 0xe4, 0x3a,
	0x65, 0xb6, 0xbc, 0xaf, 0x79, 0x12, 0xa7, 0xc4, 0xbc, 0x35, 0xf3, 0xe5, 0xec, 0xc9, 0xa5, 0x26,
	0x6f, 0xc1, 0xbc, 0x25, 0xf3, 0xf7, 0x98, 0x34, 0x38, 0x08, 0x66, 0x13, 0xbb, 0xee, 0xe4, 0x4b,
	0x19, 0x95, 0x60, 0xe4, 0xb3, 0xa1, 0x9e, 0xd6, 0x75, 0xc7, 0xac, 0x70, 0x13, 0x6e, 0xe4, 0x06,
	0xa6, 0xc2, 0xe7, 0x79, 0xd9, 0x2f, 0x29, 0xa1, 0xfc, 0x5d, 0xd5, 0x97, 0x8c, 0x36, 0x6c, 0xe1,
	0xbe, 0x58, 0xd6, 0xc7, 0xe7, 0xf7, 0xc5, 0xd6, 0xef, 0x8b, 0x50, 0x3d, 0xf0, 0x69, 0x94, 0x71,
	0xfd, 0x5e, 0xbe, 0x07, 0x77, 0xcc, 0xd2, 0x7b, 0xcd, 0xc8, 0x24, 0x21, 0x81, 0x98, 0xbd, 0xac,
	0x90, 0x85, 0x3f, 0x80, 0xdb, 0x39, 0xbd, 0x9b, 0x09, 0x11, 0xb3, 0xb6, 0x11, 0x41, 0x05, 0x7c,
	0x0b, 0xae, 0xe7, 0x9c, 0x6c, 0x87, 0x36, 0xe7, 0x31, 0x47, 0x45, 0xfc, 0x21, 0xac, 0xe7, 0xf0,
	0x8e, 0xca, 0xd4, 0x9e, 0xcf, 0x02, 0x12, 0x45, 0x24, 0x44, 0x25, 0xbc, 0x0e, 0x37, 0x72, 0xb2,
	0x47, 0x2f, 0x94, 0x2d, 0x61, 0x1b, 0x6e, 0xce, 0x11, 0x17, 0x5b, 0x96, 0xf1, 0x6d, 0xc0, 0x73,
	0x4c, 0x87, 0x9d, 0xfb, 0x11, 0x0d, 0xd1, 0x0a, 0xbe, 0x0b, 0x76, 0x8e, 0x1b, 0xb0, 0x9f, 0x37,
	0x0c, 0x2a, 0x2f, 0xe8, 0xe3, 0x71, 0x40, 0xd2, 0x54, 0xdb, 0x57, 0x99, 0x77, 0xa9, 0x1b, 0x8b,
	0x36, 0x8b, 0xb3, 0xe1, 0xe8, 0x20, 0x63, 0x61, 0x8a, 0xe0, 0x12, 0xd7, 0x61, 0x54, 0x98, 0xfe,
	0x42, 0xd5, 0x4b, 0xa6, 0x1f, 0xd1, 0x74, 0xec, 0x8b, 0x60, 0x84, 0x6a, 0xf3, 0x21, 0xdc, 0xd1,
	0x61, 0x7e, 0x49, 0x18, 0xe1, 0xbe, 0xf4, 0x1d, 0xd5, 0xf1, 0x1d, 0xb8, 0x95, 0xd3, 0x07, 0x94,
	0x8f, 0xdf, 0xf8, 0x9c, 0xf4, 0x7c, 0x46, 0x03, 0xb4, 0xfa, 0x2e, 0x4a, 0x5b, 0x19, 0x6c, 0xfd,
	0xd2, 0x02, 0x74, 0xf9, 0xb2, 0xc6, 0x08, 0x6a, 0xbd, 0x9d, 0x1f, 0xb8, 0xc7, 0xe6, 0xd1, 0x83,
	0xae, 0xe1, 0x1b, 0xb0, 0xa6, 0x90, 0xfe, 0x9e, 0xd3, 0xe9, 0xb9, 0x87, 0x3b, 0xfd, 0x43, 0x64,
	0xe1, 0xeb, 0x50, 0x57, 0xe0, 0xd1, 0xeb, 0x57, 0x6e, 0xa7, 0xdf, 0x79, 0x89, 0x0a, 0x33, 0xe8,
	0xb8, 0xe7, 0xb4, 0xdd, 0xd7, 0x4e, 0x17, 0x15, 0x67, 0xca, 0xbe, 0xea, 0xb8, 0x5d, 0xa9, 0xac,
	0x84, 0x6f, 0x02, 0x52, 0x48, 0xaf, 0xd5, 0x3f, 0xcc, 0xd1, 0xa5, 0xad, 0x08, 0xd6, 0x2e, 0x3d,
	0xbd, 0xe4, 0xd6, 0xf9, 0xc7, 0x17, 0xba, 0x26, 0xf5, 0x2b, 0x64, 0x76, 0xa4, 0x85, 0x6b, 0x50,
	0x6e, 0x9f, 0xb8, 0x6d, 0xa7, 0xbb, 0xf3, 0x0a, 0x15, 0x66, 0x5b, 0x72, 0xbd, 0x45, 0x79, 0x9a,
	0x42, 0xe6, 0x4f, 0x2b, 0x6d, 0xbd, 0x86, 0xaa, 0x19, 0xa5, 0xea, 0xa4, 0x2a, 0xac, 0xb8, 0x27,
	0x9d, 0x6e, 0xef, 0xb5, 0x8b, 0xae, 0x49, 0x8d, 0xee, 0xc9, 0xf1, 0x6b, 0x57, 0xae, 0x2c, 0x0c,
	0xb0, 0xec, 0x9e, 0x1c, 0xb5, 0xdd, 0x1d, 0x54, 0xc0, 0xab, 0x00, 0xee, 0xc9, 0x41, 0xa7, 0xdb,
	0xe9, 0x1f, 0xb6, 0xf7, 0x51, 0x11, 0xaf, 0x41, 0xd5, 0x3d, 0x69, 0x9f, 0xb8, 0xce, 0xce, 0xfe,
	0x8e, 0xbb, 0x83, 0x4a, 0x5b, 0x7f, 0x2e, 0xc2, 0x75, 0x5d, 0xc0, 0xf3, 0xda, 0xd7, 0xe1, 0xc6,
	0x02, 0xe8, 0x1d, 0x8b, 0x11, 0xe1, 0xc8, 0xc2, 0x1b, 0x70, 0x7f, 0x91, 0x38, 0x20, 0xe4, 0xf8,
	0x9c, 0x70, 0x77, 0xc4, 0x49, 0x3a, 0x8a, 0x23, 0x59, 0xfe, 0x0f, 0xe0, 0xc3, 0x45, 0x99, 0xbd,
	0x98, 0x9d, 0x52, 0x3e, 0xd6, 0x59, 0x43, 0x45, 0x59, 0x17, 0x8b, 0x02, 0x0e, 0x49, 0x89, 0xd8,
	0x27, 0xe7, 0x34, 0x20, 0xa8, 0xf4, 0x36, 0x6d, 0xf6, 0x7f, 0x15, 0x73, 0xd9, 0x10, 0x77, 0xc1,
	0x5e, 0xa4, 0xbf, 0xa2, 0x09, 0x31, 0x9b, 0x97, 0xdf, 0xde, 0xdc, 0xe3, 0xb1, 0x20, 0x81, 0xd8,
	0xf3, 0xa3, 0x08, 0xad, 0xc8, 0xea, 0x5f, 0xa4, 0x65, 0x6b, 0xb8, 0x13, 0x54, 0x7e, 0xdb, 0xea,
	0xbc, 0xf0, 0xf6, 0x46, 0x24, 0x38, 0x43, 0x15, 0x59, 0x93, 0x8b, 0x02, 0xa6, 0xa6, 0x11, 0xc8,
	0xce, 0xbe, 0x74, 0x68, 0xfe, 0x17, 0x16, 0x55, 0xf1, 0x23, 0x78, 0xb0, 0x48, 0x1e, 0x31, 0x32,
	0x8e, 0x19, 0x0d, 0xa4, 0x3f, 0x7b, 0x72, 0xc0, 0xa1, 0xda, 0xdb, 0xa7, 0xe7, 0x42, 0xaa, 0xc2,
	0x50, 0x1d, 0x37, 0xe0, 0xee, 0xa5, 0x23, 0xfc, 0x34, 0x4d, 0x46, 0xdc, 0x4f, 0xd5, 0xb8, 0x42,
	0xab, 0x5b, 0x3f, 0x81, 0x9b, 0xb2, 0xfd, 0x7c, 0xc1, 0xe9, 0x64, 0x3e, 0x97, 0x0d, 0xb8, 0xfb,
	0x2e, 0xdc, 0xdb, 0xcb, 0x38, 0x27, 0x4c, 0x20, 0x0b, 0x3f, 0x84, 0x7b, 0xef, 0x94, 0xe8, 0x92,
	0x37, 0x07, 0x94, 0xa7, 0x02, 0x15, 0x64, 0xde, 0xaf, 0x12, 0xe9, 0x93, 0x20, 0x66, 0x21, 0x2a,
	0x6e, 0x9d, 0xc2, 0x9a, 0x74, 0x69, 0xfe, 0xec, 0x3b, 0x70, 0xeb, 0x12, 0xe4, 0xf5, 0x22, 0x9f,
	0x32, 0x74, 0x4d, 0xc6, 0xec, 0x32, 0xa5, 0xd5, 0xbf, 0x40, 0xd6, 0xd5, 0xe4, 0x33, 0x54, 0xd8,
	0xfa, 0x9d, 0x05, 0x28, 0x4f, 0xce, 0x01, 0x31, 0xff, 0xec, 0xee, 0x82, 0x2d, 0xa5, 0x29, 0x27,
	0x2f, 0x89, 0x68, 0x33, 0xc1, 0xe3, 0x64, 0x6a, 0xea, 0x06, 0x59, 0xb2, 0x9e, 0x3b, 0xe9, 0x05,
	0xd1, 0x66, 0xfe, 0x20, 0x52, 0xa3, 0x7a, 0x15, 0xa0, 0x93, 0xb6, 0xc7, 0x59, 0xe4, 0x8b, 0x98,
	0xa3, 0x12, 0xfe, 0x06, 0x3c, 0xbc, 0xac, 0xda, 0x73, 0xc2, 0x64, 0x9f, 0x0c, 0xb2, 0xe1, 0x3e,
	0x4d, 0xf5, 0xb6, 0xb2, 0x0c, 0xc7, 0xbb, 0xc4, 0x8e, 0xc8, 0xd8, 0x94, 0x1b, 0x42, 0x5b, 0xfb,
	0x80, 0xcd, 0xe5, 0xbc, 0x33, 0xf7, 0x35, 0xe0, 0x36, 0xe0, 0xb9, 0xa5, 0x11, 0x40, 0xd6, 0x25,
	0x7c, 0x97, 0x0a, 0x85, 0x17, 0xb6, 0xbf, 0x03, 0x2b, 0x6f, 0xa8, 0x7a, 0x23, 0xe1, 0x87, 0x4d,
	0xfd, 0xcd, 0xa7, 0x99, 0x7f, 0xf3, 0x69, 0xb6, 0x59, 0x36, 0xfe, 0xd2, 0x8f, 0x32, 0x72, 0x9c,
	0xc8, 0x99, 0x9a, 0xda, 0x7f, 0xfb, 0x45, 0x51, 0xff, 0x23, 0x97, 0x7b, 0x3a, 0x6c, 0xfb, 0xbb,
	0x50, 0x56, 0xbb, 0xe3, 0x4c, 0xbc, 0xcf, 0xf6, 0xbf, 0x9b, 0xed, 0xea, 0xc8, 0xe3, 0x4c, 0x6c,
	0xbf, 0x84, 0xba, 0xda, 0x1f, 0x4a, 0xff, 0xdf, 0xd3, 0x86, 0x7f, 0x18, 0x25, 0x55, 0xb9, 0x53,
	0x05, 0xae, 0xc3, 0xb6, 0x3b, 0xb0, 0x3a, 0xa7, 0xe8, 0x3d, 0xcd, 0xf9, 0xa7, 0xd1, 0x54, 0x9b,
	0x69, 0x92, 0x36, 0x7d, 0x1f, 0x2a, 0x4a, 0x95, 0xa0, 0x6c, 0xfa, 0x3e, 0x5a, 0xfe, 0x65, 0xb4,
	0xa8, 0x48, 0xb8, 0x94, 0x4d, 0xb7, 0x5f, 0xc1, 0x9a, 0xd2, 0x30, 0x88, 0x63, 0x11, 0xc5, 0xea,
	0x23, 0xc9, 0x7b, 0xe8, 0xf9, 0xb7, 0xd1, 0xa3, 0x1c, 0xd9, 0x9d, 0x6d, 0xdd, 0x3d, 0xfa, 0xcb,
	0xd7, 0xf7, 0xad, 0xbf, 0x7e, 0x7d, 0xdf, 0xfa, 0xcf, 0xd7, 0xf7, 0x2d, 0xf8, 0x28, 0x88, 0xc7,
	0xcd, 0xd4, 0x17, 0x71, 0x3a, 0xa2, 0x91, 0x3f, 0x48, 0x9b, 0xfd, 0xb3, 0xe9, 0x1b, 0x3f, 0x8a,
	0x88, 0x68, 0x46, 0x74, 0x30, 0x53, 0xbf, 0x5b, 0x9f, 0xe1, 0x32, 0xdf, 0x3f, 0x2c, 0x9b, 0xef,
	0x39, 0xe9, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x45, 0x12, 0x9f, 0xe7, 0xe6, 0x13, 0x00, 0x00,
}
